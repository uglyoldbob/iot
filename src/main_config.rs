//! Contains code related to the main configuration of the application

use egui_multiwin::egui;

use crate::ca::{ComplexName, ProxyConfig};

#[cfg(target_os = "linux")]
/// Returns the default config file.
pub fn default_config_path() -> std::path::PathBuf {
    std::path::PathBuf::from("/etc/rust-iot/")
}

#[cfg(target_os = "windows")]
/// Returns the default config file.
pub fn default_config_path() -> std::path::PathBuf {
    std::path::PathBuf::from("./")
}

/// The main configuration for the application
#[derive(
    Clone,
    Debug,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct GeneralSettings {
    /// The name of the cookie to use.
    pub cookie: String,
    /// The path to get to the static content of the site
    pub static_content: String,
}

impl Default for GeneralSettings {
    fn default() -> Self {
        Self::new()
    }
}

impl GeneralSettings {
    /// Construct a blank Self
    fn new() -> Self {
        Self {
            cookie: "".into(),
            static_content: "./content".into(),
        }
    }
}

/// The admin configuration for the application
#[derive(
    Clone,
    Debug,
    Default,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct AdminSettings {
    /// The password for the administrator
    pub pass: userprompt::Password2,
    /// The n parameter for expanding passwords
    pub n: u8,
    /// The r parameter for expanding passwords
    pub r: u32,
    /// The p parameter for expanding passwords
    pub p: u32,
}

impl AdminSettings {
    /// Construct a blank Self
    fn new() -> Self {
        Self {
            pass: userprompt::Password2::new("".into()),
            n: 1,
            r: 1,
            p: 1,
        }
    }
}

/// The http configuration for the application
#[derive(
    Clone,
    Debug,
    Default,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct HttpSettings {
    /// The port number to listen on
    pub port: u16,
}

impl HttpSettings {
    /// Construct a blank Self
    fn new() -> Self {
        Self { port: 3 }
    }
}

/// The location of a https certificate. If it is specified as `New`, it will be created by a specified ca.
#[derive(
    Clone,
    Debug,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub enum HttpsCertificateLocationAnswers {
    /// The path for an existing certificate that should be loaded
    Existing {
        /// The path for the existing certificate
        path: userprompt::FileOpen,
        /// The password for the existing certificate
        password: userprompt::Password2,
    },
    /// The certificate is generated by the ca creation process, and should be deleted in destruction
    New {
        /// The path where the new certificate should be put
        path: userprompt::FileCreate,
        /// The name of the ca entity that should create the certificate
        ca_name: String,
    },
}

/// The location of a https certificate. If it is specified as `New`, it will be created by a specified ca.
#[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]
pub enum HttpsCertificateLocation {
    /// The path for an existing certificate that should be loaded
    Existing {
        /// The path for the existing certificate
        path: std::path::PathBuf,
        /// The password for the existing certificate
        password: String,
    },
    /// The certificate is generated by the ca creation process, and should be deleted in destruction
    New {
        /// The path where the new certificate should be put
        path: std::path::PathBuf,
        /// The name of the ca entity that should create the certificate
        ca_name: String,
        /// The password for the certificate
        password: String,
    },
}

impl From<HttpsCertificateLocationAnswers> for HttpsCertificateLocation {
    fn from(value: HttpsCertificateLocationAnswers) -> Self {
        match value {
            HttpsCertificateLocationAnswers::Existing { path, password } => Self::Existing {
                path: path.to_path_buf(),
                password: password.to_string(),
            },
            // Generate a random 32 digit password for the certificate
            HttpsCertificateLocationAnswers::New { path, ca_name } => Self::New {
                path: path.to_path_buf(),
                ca_name,
                password: crate::ca::generate_password(32),
            },
        }
    }
}

impl HttpsCertificateLocation {
    /// Destroy the certificate by deleting the file if it was created by the construction process
    pub fn destroy(&self) {
        if let HttpsCertificateLocation::New {
            path,
            ca_name: _,
            password: _,
        } = self
        {
            let b = (*path).to_owned();
            std::fs::remove_file(b).unwrap();
        }
    }

    /// Retrieve the password for the certificate
    pub fn password(&self) -> &str {
        match self {
            HttpsCertificateLocation::Existing { path: _, password } => password.as_str(),
            HttpsCertificateLocation::New {
                path: _,
                ca_name: _,
                password,
            } => password.as_str(),
        }
    }
}

impl Default for HttpsCertificateLocationAnswers {
    fn default() -> Self {
        Self::Existing {
            path: Default::default(),
            password: Default::default(),
        }
    }
}

impl Default for HttpsCertificateLocation {
    fn default() -> Self {
        Self::Existing {
            path: std::path::PathBuf::default(),
            password: String::default(),
        }
    }
}

impl HttpsCertificateLocation {
    /// Retrieves the path for the certificate, not checking to see if the file actually exists
    fn path(self) -> std::path::PathBuf {
        match self {
            HttpsCertificateLocation::Existing { path, password: _ } => path,
            HttpsCertificateLocation::New {
                path,
                ca_name: _,
                password: _,
            } => path,
        }
    }

    /// Returns true if the file exists
    pub fn exists(&self) -> bool {
        match self {
            HttpsCertificateLocation::Existing { path, password: _ } => path.exists(),
            HttpsCertificateLocation::New {
                path,
                ca_name: _,
                password: _,
            } => path.exists(),
        }
    }

    /// Returns Some if the certificate should be create by a ca
    pub fn create_by_ca(&self) -> Option<String> {
        if let HttpsCertificateLocation::New {
            path: _,
            ca_name,
            password: _,
        } = self
        {
            Some(ca_name.clone())
        } else {
            None
        }
    }

    /// Get the location
    pub fn pathbuf(&self) -> std::path::PathBuf {
        match self {
            HttpsCertificateLocation::Existing { path, password: _ } => path.to_path_buf(),
            HttpsCertificateLocation::New {
                path,
                ca_name: _,
                password: _,
            } => path.to_path_buf(),
        }
    }
}

/// The https configuration for the application
#[derive(
    Clone,
    Debug,
    Default,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct HttpsSettingsAnswers {
    /// The path to the p12 certificate to use for the https server certificate
    pub certificate: HttpsCertificateLocationAnswers,
    /// The port number to listen on
    pub port: u16,
    /// True when a user certificate should be required to access the system
    pub require_certificate: bool,
}

impl HttpsSettingsAnswers {
    /// Construct a blank Self
    fn new() -> Self {
        Self {
            certificate: HttpsCertificateLocationAnswers::default(),
            port: 4,
            require_certificate: false,
        }
    }
}

impl From<HttpsSettingsAnswers> for HttpsSettings {
    fn from(value: HttpsSettingsAnswers) -> Self {
        Self {
            certificate: value.certificate.into(),
            port: value.port,
            require_certificate: value.require_certificate,
        }
    }
}

/// The https configuration for the application
#[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize)]
pub struct HttpsSettings {
    /// The path to the p12 certificate to use for the https server certificate
    pub certificate: HttpsCertificateLocation,
    /// The port number to listen on
    pub port: u16,
    /// True when a user certificate should be required to access the system
    pub require_certificate: bool,
}

impl HttpsSettings {
    /// Construct a blank Self
    fn new() -> Self {
        Self {
            certificate: HttpsCertificateLocation::default(),
            port: 4,
            require_certificate: false,
        }
    }
}

/// The database configuration for the application
#[derive(
    Clone,
    Debug,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct DatabaseSettings {
    /// The username
    pub username: String,
    /// The password
    pub password: userprompt::Password2,
    /// The name of the database
    pub name: String,
    /// The url for the database
    pub url: String,
}

impl Default for DatabaseSettings {
    fn default() -> Self {
        Self::new()
    }
}

impl DatabaseSettings {
    /// Construct a blank Self
    fn new() -> Self {
        Self {
            username: "dummy".into(),
            password: userprompt::Password2::new("dummy".into()),
            name: "dummy".into(),
            url: "dummy".into(),
        }
    }
}

/// The main configuration of the application
#[derive(
    Clone,
    Debug,
    Default,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct MainConfigurationAnswers {
    /// The username to run the service as
    pub username: String,
    /// The password for the user
    pub password: Option<userprompt::Password2>,
    /// General settings
    pub general: GeneralSettings,
    /// Admin user settings
    pub admin: AdminSettings,
    /// Settings for the http server
    pub http: Option<HttpSettings>,
    /// Settings for the https server
    pub https: Option<HttpsSettingsAnswers>,
    /// Settings for the database
    pub database: DatabaseSettings,
    /// The public name of the service, contains example.com/asdf for the example
    pub public_names: Vec<ComplexName>,
    /// The optional proxy configuration
    pub proxy_config: Option<ProxyConfig>,
    /// The settings for a pki
    pub pki: crate::ca::PkiConfigurationEnum,
    /// The desired minimum debug level
    pub debug_level: service::LogLevel,
    /// Is tpm2 hardware required to setup the pki?
    #[cfg(feature = "tpm2")]
    pub tpm2_required: bool,
}

/// The main configuration of the application
#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct MainConfiguration {
    /// General settings
    pub general: GeneralSettings,
    /// Admin user settings
    pub admin: AdminSettings,
    /// Settings for the http server
    pub http: Option<HttpSettings>,
    /// Settings for the https server
    pub https: Option<HttpsSettings>,
    /// Settings for the database
    pub database: DatabaseSettings,
    /// The public name of the service, contains example.com/asdf for the example
    pub public_names: Vec<ComplexName>,
    /// The optional proxy configuration
    pub proxy_config: Option<ProxyConfig>,
    /// Settings for client certificates
    pub client_certs: Option<Vec<String>>,
    /// The settings for a pki
    pub pki: crate::ca::PkiConfigurationEnum,
    /// The desired minimum debug level
    pub debug_level: Option<service::LogLevel>,
    /// Is tpm2 hardware required to setup the pki?
    #[cfg(feature = "tpm2")]
    pub tpm2_required: bool,
}

impl Default for MainConfiguration {
    fn default() -> Self {
        Self::new()
    }
}

impl MainConfiguration {
    /// Construct an empty configuration file
    pub fn new() -> Self {
        Self {
            general: GeneralSettings::new(),
            admin: AdminSettings::new(),
            http: None,
            https: None,
            proxy_config: None,
            database: DatabaseSettings::new(),
            public_names: Vec::new(),
            client_certs: None,
            pki: crate::ca::PkiConfigurationEnum::new(),
            debug_level: Some(service::LogLevel::default()),
            tpm2_required: true,
        }
    }

    /// Process the answers, cloning them into self.
    fn process_answers(&mut self, answers: &MainConfigurationAnswers) {
        self.general = answers.general.clone();
        self.admin = answers.admin.clone();
        self.http = answers.http.clone();
        self.https = answers.https.clone().map(|a| a.into());
        self.database = answers.database.clone();
        self.public_names = answers.public_names.clone();
        self.proxy_config = answers.proxy_config.clone();
        self.pki = answers.pki.clone();
        self.debug_level = Some(answers.debug_level.clone());
        self.tpm2_required = answers.tpm2_required;
    }

    /// Remove relative paths
    pub fn remove_relative_paths(&mut self) {
        if let Some(https) = &mut self.https {
            match &mut https.certificate {
                HttpsCertificateLocation::Existing { path, password: _ } => {
                    if path.is_relative() {
                        *path = path.canonicalize().unwrap();
                    }
                }
                HttpsCertificateLocation::New {
                    path,
                    ca_name: _,
                    password: _,
                } => {
                    if path.is_relative() {
                        *path = path.canonicalize().unwrap();
                    }
                }
            }
        }
        self.pki.remove_relative_paths();
    }

    /// Fill out this configuration file with answers from the specified answer configuration
    pub fn provide_answers(&mut self, answers: &MainConfigurationAnswers) {
        self.process_answers(answers)
    }

    /// Return the port number for the http server
    pub fn get_http_port(&self) -> Option<u16> {
        self.http.as_ref().map(|a| a.port)
    }

    /// Return the port number for the https server
    pub fn get_https_port(&self) -> Option<u16> {
        self.https.as_ref().map(|a| a.port)
    }
}
