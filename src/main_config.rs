//! Contains code related to the main configuration of the application

use crate::tpm2;
use der::Decode;
use egui_multiwin::egui;

use crate::ca::{ComplexName, HttpsCertificate, ProxyConfig};

use std::io::Write;
use tokio::io::AsyncReadExt;
use userprompt::Prompting;

#[cfg(target_os = "linux")]
/// Returns the default config file.
pub fn default_config_path() -> std::path::PathBuf {
    std::path::PathBuf::from("/etc/rust-iot/")
}

#[cfg(target_os = "windows")]
/// Returns the default config file.
pub fn default_config_path() -> std::path::PathBuf {
    std::path::PathBuf::from("./")
}

/// The main configuration for the application
#[derive(
    Clone,
    Debug,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct GeneralSettings {
    #[PromptComment = "The name of the cookie to use for the website"]
    /// The name of the cookie to use.
    pub cookie: String,
    #[PromptComment = "The path for the static content of the website"]
    /// The path to get to the static content of the site
    pub static_content: String,
}

impl Default for GeneralSettings {
    fn default() -> Self {
        Self::new()
    }
}

impl GeneralSettings {
    /// Construct a blank Self
    fn new() -> Self {
        Self {
            cookie: "".into(),
            static_content: "./content".into(),
        }
    }
}

/// The admin configuration for the application
#[derive(
    Clone,
    Debug,
    Default,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct AdminSettings {
    #[PromptComment = "The administrator password"]
    /// The password for the administrator
    pub pass: userprompt::Password2,
}

/// The http configuration for the application
#[derive(
    Clone,
    Debug,
    Default,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct HttpSettings {
    #[PromptComment = "The port number to listen on"]
    /// The port number to listen on
    pub port: u16,
}

/// The location of a https certificate. If it is specified as `New`, it will be created by a specified ca.
#[derive(
    Clone,
    Debug,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub enum HttpsCertificateLocationAnswers {
    #[PromptComment = "The https certificate is located in the hsm"]
    /// The certificate should be contained in the hsm
    HsmGenerated,
    #[PromptComment = "An existing certificate should be used for the https certificate"]
    /// The path for an existing certificate that should be loaded
    Existing {
        #[PromptComment = "The path of the existing p12 certificate"]
        /// The path for the existing certificate
        path: userprompt::FileOpen,
        #[PromptComment = "The password for the certificate"]
        /// The password for the existing certificate
        password: userprompt::Password2,
    },
    /// The certificate is generated by the ca creation process, and should be deleted in destruction
    New {
        #[PromptComment = "Where the new p12 certificate should be stored"]
        /// The path where the new certificate should be put
        path: userprompt::FileCreate,
        #[PromptComment = "The name of the ca entity that should create the https certificate"]
        /// The name of the ca entity that should create the certificate
        ca_name: String,
    },
}

/// The location of a https certificate. If it is specified as `New`, it will be created by a specified ca.
#[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]
pub enum HttpsCertificateLocation {
    /// The certificate should be contained in the hsm
    HsmGenerated,
    /// The path for an existing certificate that should be loaded
    Existing {
        /// The path for the existing certificate
        path: std::path::PathBuf,
        /// The password for the existing certificate
        password: String,
    },
    /// The certificate is generated by the ca creation process, and should be deleted in destruction
    New {
        /// The path where the new certificate should be put
        path: std::path::PathBuf,
        /// The name of the ca entity that should create the certificate
        ca_name: String,
        /// The password for the certificate
        password: String,
    },
}

impl From<HttpsCertificateLocationAnswers> for HttpsCertificateLocation {
    fn from(value: HttpsCertificateLocationAnswers) -> Self {
        match value {
            HttpsCertificateLocationAnswers::HsmGenerated => HttpsCertificateLocation::HsmGenerated,
            HttpsCertificateLocationAnswers::Existing { path, password } => Self::Existing {
                path: path.to_path_buf(),
                password: password.to_string(),
            },
            // Generate a random 32 digit password for the certificate
            HttpsCertificateLocationAnswers::New { path, ca_name } => Self::New {
                path: path.to_path_buf(),
                ca_name,
                password: crate::utility::generate_password(32),
            },
        }
    }
}

impl HttpsCertificateLocation {
    /// Get a usable reference to use the https certificate
    pub fn get_usable(&self) -> HttpsCertificate {
        let process_pkcs12 = |pkcs12: Vec<u8>, password: &str| {
            let pkcs12 =
                cert_common::pkcs12::Pkcs12::load_from_data(&pkcs12, password.as_bytes(), 0);
            let cert_der = pkcs12.cert;

            let x509_cert = x509_cert::Certificate::from_der(&cert_der).unwrap();

            HttpsCertificate {
                algorithm: x509_cert.signature_algorithm.try_into().unwrap(),
                cert: cert_der,
                keypair: Some(crate::ca::Keypair::NotHsm(pkcs12.pkey.clone())),
                attributes: Vec::new(),
            }
        };

        match self {
            HttpsCertificateLocation::HsmGenerated => {
                todo!()
            }
            HttpsCertificateLocation::Existing { path, password } => {
                use std::io::Read;
                let mut certbytes = vec![];
                let mut certf = std::fs::File::open(path).unwrap();
                service::log::info!("Loading https certificate from {}", path.display());
                certf.read_to_end(&mut certbytes).unwrap();
                process_pkcs12(certbytes, password)
            }
            HttpsCertificateLocation::New {
                path,
                ca_name: _,
                password,
            } => {
                use std::io::Read;
                let mut certbytes = vec![];
                service::log::info!(
                    "Loading generated https certificate from {}",
                    path.display()
                );
                let mut certf = std::fs::File::open(path).unwrap();
                certf.read_to_end(&mut certbytes).unwrap();
                process_pkcs12(certbytes, password)
            }
        }
    }

    /// Construct a temporary file for being able to remove relative file paths
    pub async fn make_dummy(&self) {
        if let HttpsCertificateLocation::New {
            path,
            ca_name: _,
            password: _,
        } = self
        {
            use tokio::io::AsyncWriteExt;
            let pb = (*path).to_owned();
            let mut f = tokio::fs::File::create(&pb).await.unwrap();
            f.write_all(" ".as_bytes())
                .await
                .expect("Failed to write dummy https certificate");
        }
    }

    /// Destroy the certificate by deleting the file if it was created by the construction process
    pub fn destroy(&self) {
        if let HttpsCertificateLocation::New {
            path,
            ca_name: _,
            password: _,
        } = self
        {
            let b = (*path).to_owned();
            std::fs::remove_file(b).unwrap();
        }
    }

    /// Retrieve the password for the certificate
    pub fn password(&self) -> Option<&str> {
        match self {
            HttpsCertificateLocation::HsmGenerated => None,
            HttpsCertificateLocation::Existing { path: _, password } => Some(password.as_str()),
            HttpsCertificateLocation::New {
                path: _,
                ca_name: _,
                password,
            } => Some(password.as_str()),
        }
    }
}

impl Default for HttpsCertificateLocationAnswers {
    fn default() -> Self {
        Self::Existing {
            path: Default::default(),
            password: Default::default(),
        }
    }
}

impl Default for HttpsCertificateLocation {
    fn default() -> Self {
        Self::Existing {
            path: std::path::PathBuf::default(),
            password: String::default(),
        }
    }
}

impl HttpsCertificateLocation {
    /// Returns true if the certificate exists
    pub fn exists(&self) -> bool {
        match self {
            HttpsCertificateLocation::HsmGenerated => false,
            HttpsCertificateLocation::Existing { path, password: _ } => path.exists(),
            HttpsCertificateLocation::New {
                path,
                ca_name: _,
                password: _,
            } => path.exists(),
        }
    }

    /// Returns Some if the certificate should be create by a ca as a file
    pub fn create_by_ca(&self) -> Option<String> {
        if let HttpsCertificateLocation::New {
            path: _,
            ca_name,
            password: _,
        } = self
        {
            Some(ca_name.clone())
        } else {
            None
        }
    }

    /// Get the location for the file
    pub fn pathbuf(&self) -> Option<std::path::PathBuf> {
        match self {
            HttpsCertificateLocation::HsmGenerated => None,
            HttpsCertificateLocation::Existing { path, password: _ } => Some(path.to_path_buf()),
            HttpsCertificateLocation::New {
                path,
                ca_name: _,
                password: _,
            } => Some(path.to_path_buf()),
        }
    }
}

/// The https configuration for the application
#[derive(
    Clone,
    Debug,
    Default,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct HttpsSettingsAnswers {
    #[PromptComment = "The path to the p12 certificate to use for the https server certificate"]
    /// The path to the p12 certificate to use for the https server certificate
    pub certificate: HttpsCertificateLocationAnswers,
    #[PromptComment = "The port number to listen on"]
    /// The port number to listen on
    pub port: u16,
    #[PromptComment = "Should a user certificate be required to access any part of the authority (this includes requesting a new certificate)? This is probably not desired"]
    /// True when a user certificate should be required to access the system
    pub require_certificate: bool,
}

impl From<HttpsSettingsAnswers> for HttpsSettings {
    fn from(value: HttpsSettingsAnswers) -> Self {
        Self {
            certificate: value.certificate.into(),
            port: value.port,
            require_certificate: value.require_certificate,
        }
    }
}

/// The https configuration for the application
#[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize)]
pub struct HttpsSettings {
    /// The path to the p12 certificate to use for the https server certificate
    pub certificate: HttpsCertificateLocation,
    /// The port number to listen on
    pub port: u16,
    /// True when a user certificate should be required to access the system
    pub require_certificate: bool,
}

/// The database configuration for the application
#[derive(
    Clone,
    Debug,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct DatabaseSettings {
    #[PromptComment = "The database username"]
    /// The username
    pub username: String,
    #[PromptComment = "The database password"]
    /// The password
    pub password: userprompt::Password2,
    #[PromptComment = "The database name"]
    /// The name of the database
    pub name: String,
    #[PromptComment = "The url for the database"]
    /// The url for the database
    pub url: String,
}

impl Default for DatabaseSettings {
    fn default() -> Self {
        Self::new()
    }
}

impl DatabaseSettings {
    /// Construct a blank Self
    fn new() -> Self {
        Self {
            username: "dummy".into(),
            password: userprompt::Password2::new("dummy".into()),
            name: "dummy".into(),
            url: "dummy".into(),
        }
    }
}

/// The server configuration of the application
#[derive(
    Clone,
    Debug,
    serde::Deserialize,
    serde::Serialize,
    userprompt::Prompting,
    userprompt::EguiPrompting,
)]
pub enum SecurityModuleConfiguration {
    Hardware {
        /// Is there a path override for the location of the hsm library?
        hsm_path_override: Option<userprompt::FileOpen>,
        /// The pin for the hardware security module
        hsm_pin: String,
        /// The user pin for the hardware security module
        hsm_pin2: String,
        /// The slot override for the hsm
        hsm_slot: Option<usize>,
    },
    Software(std::path::PathBuf),
}

impl Default for SecurityModuleConfiguration {
    fn default() -> Self {
        Self::Software("./".into())
    }
}

/// The configuration details specific for cgi configuration
#[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize, userprompt::Prompting,
    userprompt::EguiPrompting,)]
pub struct CgiConfiguration {
    /// The public name of the service, contains example.com/asdf for the example
    pub public_names: Vec<ComplexName>,
}

/// The server configuration of the application
#[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize)]
pub struct ServerConfiguration {
    /// General settings
    pub general: GeneralSettings,
    /// Settings for the http server
    pub http: Option<HttpSettings>,
    /// Settings for the https server
    pub https: Option<HttpsSettings>,
    /// Settings for the database
    pub database: Option<DatabaseSettings>,
    /// The public name of the service, contains example.com/asdf for the example
    pub public_names: Vec<ComplexName>,
    /// The optional proxy configuration
    pub proxy_config: Option<ProxyConfig>,
    /// Settings for client certificates
    pub client_certs: Option<Vec<std::path::PathBuf>>,
    /// The desired minimum debug level
    pub debug_level: Option<service::LogLevel>,
    /// Is tpm2 hardware required to setup the pki?
    #[cfg(feature = "tpm2")]
    pub tpm2_required: bool,
}

impl ServerConfiguration {
    /// Set the log level
    pub fn set_log_level(&self) {
        service::log::set_max_level(
            self.debug_level
                .as_ref()
                .unwrap_or(&service::LogLevel::Trace)
                .level_filter(),
        );
    }
}

/// The server configuration of the application
#[derive(
    Clone,
    Debug,
    Default,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct ServerConfigurationAnswers {
    #[PromptComment = "What username to run the service as"]
    /// The username to run the service as
    pub username: String,
    #[PromptComment = "The optional password for the user that the service will run as"]
    /// The password for the user
    pub password: Option<userprompt::Password2>,
    #[PromptComment = "General settings"]
    /// General settings
    pub general: GeneralSettings,
    #[PromptComment = "Optional settings for the http service"]
    /// Settings for the http server
    pub http: Option<HttpSettings>,
    #[PromptComment = "Optional settings for the https service"]
    /// Settings for the https server
    pub https: Option<HttpsSettingsAnswers>,
}

impl ServerConfiguration {
    /// Destroy the configuration
    pub fn destroy(&self) {
        if let Some(https) = &self.https {
            https.certificate.destroy();
        }
    }

    /// Remove relative pathnames from all paths specified
    pub async fn remove_relative_paths(&mut self) {
        if let Some(https) = &self.https {
            https.certificate.make_dummy().await;
        }
        if let Some(https) = &mut self.https {
            match &mut https.certificate {
                HttpsCertificateLocation::HsmGenerated => {}
                HttpsCertificateLocation::Existing { path, password: _ } => {
                    if path.is_relative() {
                        *path = path.canonicalize().unwrap();
                    }
                }
                HttpsCertificateLocation::New {
                    path,
                    ca_name: _,
                    password: _,
                } => {
                    if path.is_relative() {
                        *path = path.canonicalize().unwrap();
                    }
                }
            }
        }
        if let Some(https) = &self.https {
            https.certificate.destroy();
        }
    }
}

impl From<ServerConfigurationAnswers> for ServerConfiguration {
    fn from(value: ServerConfigurationAnswers) -> Self {
        Self {
            general: value.general,
            http: value.http.into(),
            https: value.https.map(|a| a.into()),
            database: value.database,
            public_names: value.public_names,
            proxy_config: value.proxy_config,
            client_certs: value
                .client_certs
                .map(|a| a.iter().map(|b| b.to_path_buf()).collect()),
            debug_level: Some(value.debug_level),
            tpm2_required: value.tpm2_required,
            security_module: todo!(),
            /*hsm_path_override: value.hsm_path_override,
            hsm_pin: crate::utility::generate_password(32),
            hsm_pin2: crate::utility::generate_password(32),
            hsm_slot: value.hsm_slot,*/
        }
    }
}

/// The main configuration of the application
#[derive(
    Clone,
    Debug,
    Default,
    userprompt::Prompting,
    userprompt::EguiPrompting,
    serde::Deserialize,
    serde::Serialize,
)]
pub struct MainConfigurationAnswers {
    #[PromptComment = "The pki configuration"]
    /// The settings for a pki
    pub pki: crate::ca::PkiConfigurationEnumAnswers,
}

impl MainConfigurationAnswers {
    /// Build a owner options
    pub fn build_owner_options(&self) -> Option<crate::ca::OwnerOptions> {
        self.pki.build_owner_options()
    }

    /// Build a service config, if possible
    pub fn make_service_config(
        &self,
        service_args: Vec<String>,
        name: &str,
        path: std::path::PathBuf,
    ) -> Option<service::ServiceConfig> {
        self.pki.make_service_config(service_args, name, path)
    }

    /// Makes extended configuration data, if applicable
    pub fn make_extended_config(&self) -> Option<ExtendedConfiguration> {
        self.pki.make_extended_config()
    }
}

/// The main configuration of the application
#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct MainConfiguration {
    /// The settings for a pki
    pub pki: crate::ca::PkiConfigurationEnum,
}

/// Perform the decryption without the tpm2 hardware
pub async fn do_without_tpm2<T: serde::de::DeserializeOwned>(
    settings_con: Vec<u8>,
    config_path: &std::path::PathBuf,
    name: &str,
) -> T {
    let mut password: Option<String> = None;
    if password.is_none() {
        let mut pw = Vec::new();
        let mut f = tokio::fs::File::open(config_path.join(format!("{}-credentials.bin", name)))
            .await
            .unwrap();
        f.read_to_end(&mut pw).await.unwrap();
        let mut pw = String::from_utf8(pw).unwrap();
        loop {
            if pw.ends_with('\n') {
                pw.pop();
                continue;
            }
            if pw.ends_with('\r') {
                pw.pop();
                continue;
            }
            break;
        }
        password = Some(pw);
    }
    if password.is_none() {
        let mut password2: userprompt::Password;
        loop {
            print!("Please enter a password:");
            std::io::stdout().flush().unwrap();
            password2 = userprompt::Password::prompt(None, None).unwrap();
            if !password2.is_empty() {
                password = Some(password2.to_string());
                break;
            }
        }
    }

    let password = password.expect("No password provided");
    let password_combined = password.as_bytes();
    let pconfig = tpm2::decrypt(settings_con, password_combined);
    let settings2 = toml::from_str(std::str::from_utf8(&pconfig).unwrap());
    if settings2.is_err() {
        panic!(
            "Failed to parse configuration file {}",
            settings2.err().unwrap()
        );
    }
    settings2.unwrap()
}

/// Perform the tpm2 operation to deserialize/decrypt the contents
pub async fn do_tpm2_operation<T: serde::de::DeserializeOwned>(
    password_combined: Option<&Vec<u8>>,
    contents: Vec<u8>,
    config_path: &std::path::PathBuf,
    name: &str,
) -> T {
    let settings: T;
    #[cfg(feature = "tpm2")]
    {
        let mut tpm2 = tpm2::Tpm2::new(tpm2::tpm2_path());

        if let Some(tpm2) = &mut tpm2 {
            if let Some(password_combined) = &password_combined {
                let pconfig = tpm2::decrypt(contents, password_combined);

                let settings2 = toml::from_str(std::str::from_utf8(&pconfig).unwrap());
                if settings2.is_err() {
                    panic!("Failed to parse configuration file");
                }
                settings = settings2.unwrap();
            } else {
                settings = do_without_tpm2(contents, config_path, name).await;
            }
        } else {
            settings = do_without_tpm2(contents, config_path, name).await;
        }
    }
    #[cfg(not(feature = "tpm2"))]
    {
        settings = do_without_tpm2(contents, config_path, name).await;
    }
    settings
}

impl MainConfiguration {
    /// Is the tpm2 required?
    pub fn tpm2_required(&self) -> bool {
        match &self.pki {
            crate::ca::PkiConfigurationEnum::Pki(pki_configuration) => {
                pki_configuration.service.tpm2_required
            }
            crate::ca::PkiConfigurationEnum::AddedCa(local_ca_configuration) => false,
            crate::ca::PkiConfigurationEnum::Ca(standalone_ca_configuration) => {
                standalone_ca_configuration.service.tpm2_required
            }
        }
    }

    /// Load the configuration
    pub async fn load(
        config_path: std::path::PathBuf,
        name: &str,
        settings_con: Vec<u8>,
        password_combined: &mut Option<Vec<u8>>,
    ) -> Self {
        #[cfg(not(feature = "tpm2"))]
        let mut password: Option<String> = None;

        #[cfg(not(feature = "tpm2"))]
        if password.is_none() {
            let mut pw = Vec::new();
            let mut f =
                tokio::fs::File::open(config_path.join(format!("{}-credentials.bin", name)))
                    .await
                    .unwrap();
            f.read_to_end(&mut pw).await.unwrap();
            let mut pw = String::from_utf8(pw).unwrap();
            loop {
                if pw.ends_with('\n') {
                    pw.pop();
                    continue;
                }
                if pw.ends_with('\r') {
                    pw.pop();
                    continue;
                }
                break;
            }
            password = Some(pw);
        }

        *password_combined = None;
        #[cfg(feature = "tpm2")]
        {
            let mut tpm2 = tpm2::Tpm2::new(tpm2::tpm2_path());

            if let Some(tpm2) = &mut tpm2 {
                let mut tpm_data = Vec::new();
                let mut f =
                    tokio::fs::File::open(config_path.join(format!("{}-password.bin", name)))
                        .await
                        .unwrap();
                f.read_to_end(&mut tpm_data).await.unwrap();

                let tpm_data = tpm2::TpmBlob::rebuild(&tpm_data);

                let epdata = tpm2.decrypt(tpm_data).unwrap();
                let protected_password = tpm2::Password::rebuild(&epdata);
                *password_combined = Some(protected_password.password().to_vec());
            }
        }

        do_tpm2_operation(
            password_combined.as_ref(),
            settings_con,
            &config_path,
            &name,
        )
        .await
    }
}

/// Extended configuration added after the initial creation of the pki/ca
#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub enum ExtendedConfiguration {
    /// Extra ca added to the existing pki instance
    ExtraPkiCaInstance {
        /// The name of the instance
        name: String,
        /// The instance to add
        instance: crate::ca::LocalCaConfiguration,
    },
    /// Extra remote ca added to the existing pki instance
    ExtraPkiRemoteCaInstance {
        /// The name of the instance
        name: String,
        /// The instance to add
        instance: crate::ca::RemoteCaConfiguration,
    },
}

impl MainConfiguration {
    /// Remove relative paths
    pub async fn remove_relative_paths(&mut self) {
        self.pki.remove_relative_paths().await;
    }

    /// Fill out this configuration file with answers from the specified answer configuration
    pub fn provide_answers(answers: &MainConfigurationAnswers) -> Self {
        Self {
            pki: crate::ca::PkiConfigurationEnum::from_config(answers.pki.clone()),
        }
    }

    /// Return the port number for the http server
    pub fn get_http_port(&self) -> Option<u16> {
        self.pki.get_http_port()
    }

    /// Return the port number for the https server
    pub fn get_https_port(&self) -> Option<u16> {
        self.pki.get_https_port()
    }
}
